---
title: "JPA 영속성 컨텍스트: 은행 장부 비유로 쉽게 이해하기"
categories:
  - CS Basics
tags:
  - JPA
  - Persistence Context
  - CS Basics
last_modified_at: 
---

## JPA 영속성 컨텍스트(Persistence Context)에 대하여

---

### 📦 데이터베이스(DB)란?

- DB는 중앙은행에서 관리하는 `돈 관리 장부`
- 모든 데이터가 영구적으로 저장되고 관리되는 `원본 데이터의 총본산`
- 은행의 모든 계좌 거래 내역이 정확하게 기록되고 보관되는 `공식적인, 최종적인 장부`
- 데이터의 일관성과 무결성을 보장하는 가장 중요한 공간

---

### 📋 영속성 컨텍스트(Persistence Context)란?

영속성 컨텍스트는 `중앙은행 장부의 사본`이자, 변경 사항을 기록하는 `임시 장부` 역할
개발 과정에서 데이터베이스에 직접 접근하는 대신, 영속성 컨텍스트를 통해 데이터를 관리

#### 중앙은행 장부의 사본 (작업 공간이자 1차 캐시)

- JPA를 통해 엔티티를 조회(`find()`)하면, DB에서 해당 데이터를 가져와 엔티티 객체로 만든 후 `영속성 컨텍스트에 저장`
- 이때 영속성 컨텍스트는 마치 DB에서 가져온 데이터의 `정확한 사본(스냅샷)`을 보관하고 있는 것과 동일
- 만약 같은 트랜잭션 내에서 동일한 엔티티를 다시 조회하면, JPA는 DB까지 가지 않고 영속성 컨텍스트에 이미 저장된 사본(객체)을 즉시 반환
- 즉, `1차 캐시(First-Level Cache)`의 역할이고, 그렇기 때문에  DB 접근 횟수를 줄일 수 있어 애플리케이션의 성능을 향상시킴

#### 변경 사항을 기록하는 임시 장부

- 영속성 컨텍스트에 있는 엔티티(즉, 영속 상태의 엔티티)의 내용을 변경(`user.update()`)하면, JPA는 이 변경을 자동으로 감지
- 이 감지된 변경 사항들은 아직 DB에 반영된 것은 아니며, 영속성 컨텍스트 내부적으로 `수정될 예정`이라고 표시되는데, 이것을 변경 감지(Dirty Checking)라 함
- 영속성 컨텍스트는 이 변경 사항들을 임시로 기록해두는 `작업 공간` 또는 `임시 장부` 역할
- DB에 바로바로 반영하는 것이 아니라, 하나의 트랜잭션 내에서 여러 변경이 일어나면 이를 모아서 효율적으로 처리

---

### 💡 영속성 컨텍스트가 DB에 반영되는 순간

- 트랜잭션이 성공적으로 `commit`될 때, 영속성 컨텍스트는 그동안 쌓여있던 모든 변경 사항들(새로 추가된 엔티티, 수정된 엔티티, 삭제된 엔티티 등)을 DB에 일괄적으로 반영(Flush)
- 즉, 중앙은행의 공식 장부에 임시 장부에 기록된 내용을 최종적으로 기록하는 순간

---

### 🔄 개념 비교

| 개념               | 역할                       | 특징                                                                |
|--------------------|----------------------------|---------------------------------------------------------------------|
| 데이터베이스(DB) | 최종적이고 영구적인 저장소 | - 중앙은행의 공식 장부 <br> - 모든 데이터의 원본                  |
| 영속성 컨텍스트  | JPA의 중간 계층, 캐시      | - DB 장부의 사본 <br> - 1차 캐시 역할 <br> - 변경 감지(Dirty Checking)으로 변경 사항 추적 |
| 트랜잭션 커밋  | 변경 사항 DB 반영 시점     | - 임시 장부의 변경 내용을 공식 장부에 기록하는 순간               |

---

### 💡 요약

영속성 컨텍스트는 JPA 애플리케이션과 DB 사이에서 매우 중요한 역할을 하는 `중간 계층`이자 `캐시`, 그리고 `변경 내용을 추적하는 작업 공간`
그리고 이는 JPA가 지향하는 개발의 편의성과 성능 최적화를 위한 핵심 메커니즘

